import sys
sys.stdin  = open('input.txt')

'''
3 * N 크기의 벽을 2 * 1 , 1 * 2 로 채우는 경우의 수
사실상 가로의 크기가 정해지면, 세로의 크기는 고정
세로의 크기가 정해지면 가로의 크기는 고정이다.
그럼 3과 3을 2 와 1로 만들 수 있는 경우의 수를 보는 것인가?
그냥 3의 크기는 만들지 못하지. 나누어 떨어지지 않기 때문이다.
6의 경우는? 2로 나누어 떨어진다 만들수 있다.
그럼 짝수의 경우만 바라보면된다고 치자
따라서 6짜리 벽을 만든다면 3가지 경우가 맞다
2를 아래깔거나 위에 깔거나만 다르고, 세로가 2인 타일을 쓰느냐 안쓰느냐라서
세로가 2인 타일은 무조건적으로 1인 타일과 함께 쓰일수 밖에 없음
그러면, 크기에 따라달라진다
가로가 2인 타일을 하나 깐다면
세로가 2인 타일을 쓰려면 무조건적으로 안깔거나 2개가 깔려야 한다
가로가 2인 타일을 두개 깐다면
세로가 2인 타일은 안쓰거나, 2개를 쓰거나 4개를 쓸 수 있다.
가로가 2인 타일을 세개 깐다면
세로가 2인 타일은 안쓰거나, 2개 쓰거나, 4개를 쓰거나, 6개를 쓸 수 있다.
그럼 여기서 세로 가로가 둬죽박죽 된다면
누적 곱이되는건가
3*2 를 만드는 건 3가지 경우 (3) 
3*4 를 만드는건 (3 * 3) + 4를 하나의 묶음으로 보는 2가지 경우의 수 11
3*6 을 만드는건 (3 * 3 * 3) + (3 + 3) + 2 
어차피 가로 2는 맨 위나 아래에서 뒤죽박죽이니까
3을 곱해주는 것으로 고정
나머지는 세로를 어디다 두느냐의 인덱스 차이?
'''
dp = [0] * 32
dp[2] = 3 # 4가 11이라는 것은
for i in range(4,32):
    if not i % 2: # 짝수면
        dp[i] = dp[i-2] * 3 + sum(dp[:i-2]) * 2 + 2
    else:
        pass
n = int(input())
print(dp[n])


